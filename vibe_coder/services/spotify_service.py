from __future__ import annotations

import logging
import time
from typing import Dict, List

import spotipy
from spotipy import SpotifyException
from spotipy.oauth2 import SpotifyOAuth
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_exponential

from vibe_coder.config import Settings
from vibe_coder.models import PlaylistResult, SpotifyAudioParams, SpotifyTrack
from vibe_coder.utils.helpers import sanitize_playlist_name


class SpotifyAuthError(Exception):
    """Authentication with Spotify failed."""


class NoRecommendationsError(Exception):
    """No recommendations returned by Spotify."""


class RateLimitError(Exception):
    """Hit Spotify rate limiting."""


class SpotifyService:
    """Spotify client wrapper with caching and validation."""

    def __init__(self, config: Settings, logger: logging.Logger | None = None) -> None:
        self._config = config
        self._logger = logger or logging.getLogger(__name__)
        self._client: spotipy.Spotify | None = None
        self._genre_cache: Dict[str, Dict[str, object]] = {}

    @property
    def client(self) -> spotipy.Spotify:
        if self._client is None:
            self._authenticate()
        return self._client

    def _authenticate(self) -> None:
        """Authenticate and store Spotify client instance."""
        try:
            auth_manager = SpotifyOAuth(
                client_id=self._config.spotify_client_id,
                client_secret=self._config.spotify_client_secret,
                redirect_uri=self._config.spotify_redirect_uri,
                scope="playlist-modify-public user-library-read",
                cache_path=".spotify_cache",
            )
            self._client = spotipy.Spotify(
                auth_manager=auth_manager, requests_timeout=self._config.spotify_request_timeout
            )
            self._logger.info("Spotify authentication successful")
        except Exception as exc:  # pragma: no cover - spotipy raises varied errors
            self._logger.error("Spotify authentication failed: %s", exc)
            raise SpotifyAuthError("Failed to authenticate with Spotify") from exc

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type(SpotifyException),
        reraise=True,
    )
    def get_available_genres(self) -> List[str]:
        """Return cached Spotify seed genres."""
        cache_key = "available_genres"
        cached = self._genre_cache.get(cache_key)
        if cached and time.time() - cached["timestamp"] < self._config.genre_cache_ttl:
            return cached["data"]  # type: ignore[return-value]

        genres = self.client.recommendation_genre_seeds()["genres"]
        self._genre_cache[cache_key] = {"data": genres, "timestamp": time.time()}
        self._logger.info("Fetched %d genres from Spotify", len(genres))
        return genres

    def recommend_tracks(self, params: SpotifyAudioParams, limit: int = 20) -> List[SpotifyTrack]:
        """Get track recommendations using clamped parameters."""
        clamped = {
            "target_valence": max(0.0, min(1.0, params.target_valence)),
            "target_energy": max(0.0, min(1.0, params.target_energy)),
            "target_danceability": max(0.0, min(1.0, params.target_danceability)),
            "min_tempo": max(40, min(220, params.min_tempo)),
            "max_tempo": max(40, min(220, params.max_tempo)),
            "seed_genres": params.seed_genres[:2],
            "limit": limit,
        }

        try:
            results = self.client.recommendations(**clamped)
            tracks = [self._normalize_track(track) for track in results.get("tracks", [])]
            if not tracks:
                raise NoRecommendationsError("Spotify returned no recommendations for this vibe")
            return tracks
        except SpotifyException as exc:
            if exc.http_status == 429:
                raise RateLimitError("Spotify rate limit hit, please retry shortly") from exc
            raise

    def create_playlist(self, name: str, tracks: List[SpotifyTrack]) -> PlaylistResult:
        """Create a playlist and add tracks in batches."""
        user = self.client.current_user()
        playlist_name = sanitize_playlist_name(name)
        playlist = self.client.user_playlist_create(
            user["id"],
            playlist_name,
            public=True,
            description=f"Generated by Vibe Coder | {len(tracks)} tracks",
        )

        track_uris = [track.uri for track in tracks]
        for i in range(0, len(track_uris), 100):
            self.client.playlist_add_items(playlist["id"], track_uris[i : i + 100])

        return PlaylistResult(
            playlist_id=playlist["id"],
            playlist_url=playlist["external_urls"]["spotify"],
            playlist_name=playlist_name,
            track_count=len(tracks),
            tracks=tracks,
        )

    @staticmethod
    def _normalize_track(track: dict) -> SpotifyTrack:
        """Normalize Spotify track to internal model."""
        return SpotifyTrack(
            id=track["id"],
            name=track["name"],
            artists=[artist["name"] for artist in track.get("artists", [])],
            uri=track["uri"],
            preview_url=track.get("preview_url"),
            duration_ms=track.get("duration_ms", 0),
        )
